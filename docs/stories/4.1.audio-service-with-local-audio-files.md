# Story 4.1: Audio Service with Local Audio Files

**Status:** Done  
**Epic:** 4 - Audio System & User Controls  
**Story Number:** 4.1  

---

## Story

**As a** developer,  
**I want** un service qui gère la lecture des fichiers audio pré-enregistrés,  
**so that** l'application peut annoncer les techniques et attaques avec des audios locaux.

---

## Acceptance Criteria

1. L'`AudioService` est créé avec la gestion de la lecture audio
2. Le service charge les fichiers audio depuis `src/assets/audio/` selon le nom de la technique/attaque
3. Le service peut jouer un audio pour une technique et une attaque données
4. Le service gère la file d'attente des audios à jouer
5. Le service expose des méthodes pour : jouer, mettre en pause, arrêter, répéter
6. Le service gère les erreurs de chargement audio gracieusement (fichier manquant, format non supporté)
7. Le service notifie les composants via observables RxJS quand un audio est terminé
8. Le service supporte la sélection de voix (masculin/féminin) en chargeant les bons fichiers audio

---

## Tasks / Subtasks

- [x] **Task 1: Implement Audio File Path Resolution** (AC: 2, 8)
  - [x] Créer une méthode pour construire le chemin audio selon la voix (language + voiceId)
  - [x] Utiliser `parseVoiceId()` depuis `settings.model.ts` pour extraire language et id
  - [x] Construire le chemin : `assets/audio/{language}/{voiceId}/{filename}.mp3`
  - [x] Normaliser les noms de fichiers (technique/attaque) pour correspondre aux fichiers audio (snake_case)

- [x] **Task 2: Implement Audio Playback Core** (AC: 1, 3)
  - [x] Implémenter `playTechnique(technique: Technique, voiceId: VoiceId): Promise<void>`
  - [x] Créer un HTMLAudioElement pour chaque audio
  - [x] Charger et jouer l'audio de l'attaque puis de la technique
  - [x] Retourner une Promise qui se résout quand tous les audios sont terminés

- [x] **Task 3: Implement Audio Queue Management** (AC: 4)
  - [x] Créer un système de file d'attente pour gérer plusieurs audios
  - [x] S'assurer qu'un audio se termine avant que le suivant commence
  - [x] Gérer la séquence : attaque → technique (ou technique seule si pas d'attaque)

- [x] **Task 4: Implement Pause/Resume/Stop Methods** (AC: 5)
  - [x] Implémenter `pauseAudio()` pour mettre en pause l'audio en cours
  - [x] Implémenter `resumeAudio()` pour reprendre l'audio en pause
  - [x] Implémenter une méthode `stopAudio()` pour arrêter complètement
  - [x] Gérer l'état de pause dans le service

- [x] **Task 5: Implement Repeat Functionality** (AC: 5)
  - [x] Implémenter `repeatLastTechnique()` pour répéter la dernière technique annoncée
  - [x] Stocker la dernière technique et voiceId joués
  - [x] Réutiliser la logique de `playTechnique()` pour la répétition

- [x] **Task 6: Implement Error Handling** (AC: 6)
  - [x] Gérer les erreurs de chargement (fichier manquant)
  - [x] Gérer les erreurs de format (format non supporté)
  - [x] Logger les erreurs sans faire planter l'application
  - [x] Retourner des Promises rejetées avec des messages d'erreur appropriés

- [x] **Task 7: Implement RxJS Observables for Audio Events** (AC: 7)
  - [x] Créer un Observable pour notifier quand un audio est terminé
  - [x] Créer un Observable pour notifier les erreurs audio
  - [x] Exposer ces observables via des méthodes publiques

- [x] **Task 8: Remove ElevenLabs Method** (AC: 1)
  - [x] Supprimer la méthode `useElevenlabs()` du service (non prévu)
  - [x] Nettoyer les commentaires faisant référence à ElevenLabs

- [x] **Task 9: Create Unit Tests** (AC: 1-8)
  - [x] Tester la résolution des chemins audio selon la voix
  - [x] Tester la lecture d'une technique complète (attaque + technique)
  - [x] Tester la file d'attente (séquence d'audios)
  - [x] Tester pause/resume/stop
  - [x] Tester la répétition
  - [x] Tester la gestion d'erreurs (fichier manquant, format invalide)
  - [x] Tester les observables (événements audio terminé, erreurs)

---

## Dev Notes

### Previous Story Insights

**Source:** Story 1.4 - Core Services Structure
- AudioService existe avec structure de base et stubs
- Méthodes déclarées : `playTechnique()`, `pauseAudio()`, `resumeAudio()`, `repeatLastTechnique()`
- Service injectable avec `providedIn: 'root'`

**Source:** Epic 2 - Data Management & Configuration
- VoiceService disponible pour charger les voix depuis `assets/audio/voices.json`
- Modèle Voice avec `id`, `language`, `gender`, `displayName`
- Fonction `parseVoiceId()` dans `settings.model.ts` pour parser le VoiceId complet

**Source:** Epic 3 - Passage Generation & Core Execution
- Technique model avec `attack`, `technique`, `position`, `order`
- PassageService utilise déjà AudioService (appel prévu dans Story 4.3)

### Technical Context

**Source:** [architecture/components.md](../../architecture/components.md)
- AudioService doit gérer la lecture audio (audios locaux uniquement)
- Interface prévue : `playTechnique(technique: Technique, voice: 'masculin' | 'féminin'): Promise<void>`
- Note: L'interface réelle utilise `VoiceId` (format `{language}_{id}`) au lieu de 'masculin'/'féminin'

**Structure des fichiers audio:**
- Organisation : `assets/audio/{language}/{voiceId}/{filename}.mp3`
- Exemples : `assets/audio/French/Male1/shomen_uchi.mp3`, `assets/audio/Japanese/Female2/ikkyo.mp3`
- Les fichiers sont en format MP3
- Les noms de fichiers sont en snake_case (ex: `shomen_uchi`, `ikkyo`, `ai_hanmi_katate_dori`)

**Normalisation des noms:**
- Les techniques/attaques/positions dans le modèle Technique peuvent être en format lisible (ex: "Shomen Uchi", "Suwariwaza", "Hanmi Handachi")
- Les fichiers audio sont **tous en minuscules uniquement** avec des underscores pour les espaces (ex: "shomen_uchi.mp3", "suwariwaza.mp3", "hanmi_handachi.mp3")
- Normalisation : convertir en minuscules, remplacer tous les espaces par des underscores, supprimer les caractères non alphanumériques (sauf underscore)
- Exemples de normalisation :
  - "Shomen Uchi" → "shomen_uchi"
  - "Suwariwaza" → "suwariwaza"
  - "Hanmi Handachi" → "hanmi_handachi"
  - "Kata Dori Men Uchi" → "kata_dori_men_uchi"

**Validation du chemin de voix:**
- Le chemin est construit comme : `assets/audio/{language}/{voiceId}/{filename}.mp3`
- Exemple : `assets/audio/French/Male1/shomen_uchi.mp3`
- Validation que la langue est 'French' ou 'Japanese'
- Validation que l'ID de voix n'est pas vide
- Le format VoiceId doit être `{language}_{id}` (ex: "French_Male1", "Japanese_Female2")

**Logique hiérarchique de lecture audio:**
- Ordre strict de lecture : **Position → Attaque → Technique**
- Seuls les éléments qui ont changé par rapport à la technique précédente sont annoncés
- Si un parent change, tous ses enfants doivent être annoncés aussi
- Exemples :
  - Technique 1: Suwariwaza + Shomen Uchi + Ikkyo → Annonce: Position + Attaque + Technique (tout est nouveau)
  - Technique 2: Suwariwaza + Shomen Uchi + Nikyo → Annonce: Technique seulement (position et attaque identiques)
  - Technique 3: Suwariwaza + Yokomen Uchi + Nikyo → Annonce: Attaque + Technique (position identique, attaque change)
  - Technique 4: Tashiwaza + Yokomen Uchi + Nikyo → Annonce: Position + Attaque + Technique (position change, donc tout est annoncé)
- Pour la répétition (`repeatLastTechnique()`), on joue toujours tout (position + attaque + technique) car c'est une action explicite

### Testing

**Test file location:** `src/app/services/audio.service.spec.ts`

**Test standards:**
- Utiliser Jasmine/Karma comme framework de test
- Tester toutes les méthodes publiques
- Mocker HTMLAudioElement pour les tests (ne pas charger de vrais fichiers audio)
- Tester les cas d'erreur (fichier manquant, erreur de chargement)
- Tester la file d'attente et la séquence d'audios
- Tester les observables RxJS

**Testing patterns:**
- Utiliser `spyOn()` pour mocker les méthodes HTMLAudioElement
- Utiliser `fakeAsync()` et `tick()` pour tester les Promises et observables
- Tester les erreurs avec `catchError()` et vérifier les logs

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-01-13 | 1.0 | Création initiale de la story | SM |
| 2025-01-15 | 1.1 | Implémentation complète de l'AudioService | Dev |

---

## Dev Agent Record

### Agent Model Used
Claude Sonnet 4.5 (Auto)

### Debug Log References
- Build réussi sans erreurs
- Tests unitaires mis à jour et passent

### Completion Notes List
- Implémentation complète de l'AudioService avec toutes les fonctionnalités requises
- **Normalisation des noms de fichiers** : conversion en minuscules uniquement avec underscores (ex: "Shomen Uchi" → "shomen_uchi")
  - Tous les espaces sont remplacés par des underscores
  - Seuls les caractères alphanumériques et underscores sont conservés
- **Validation du chemin de voix** : vérification que le format VoiceId correspond bien aux dossiers disponibles
  - Validation de la langue (French ou Japanese)
  - Validation que l'ID de voix n'est pas vide
  - Format attendu : `{language}_{id}` (ex: "French_Male1")
- **Logique hiérarchique implémentée** : comparaison avec la technique précédente pour déterminer quels audios jouer
- Ordre strict de lecture : Position → Attaque → Technique
- Seuls les éléments qui ont changé (ou dont le parent a changé) sont annoncés
- Gestion de la file d'attente pour éviter les chevauchements d'audios
- Support complet de pause/resume/stop
- Répétition de la dernière technique : joue toujours tout (position + attaque + technique) pour une action explicite
- Méthode `resetComparisonState()` ajoutée pour réinitialiser l'état lors d'un nouveau passage
- Gestion d'erreurs gracieuse avec observables RxJS pour les événements
- Méthode ElevenLabs supprimée (non prévu)
- Tests unitaires mis à jour pour refléter les nouvelles fonctionnalités

### File List
- `src/app/services/audio.service.ts` - Service complet implémenté avec logique hiérarchique
- `src/app/services/audio.service.spec.ts` - Tests unitaires mis à jour

---

## QA Results
_À remplir par le QA agent_
