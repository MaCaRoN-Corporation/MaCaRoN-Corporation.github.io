# Story 2.6: Interface Hiérarchique de Filtrage des Techniques (Mode Révision)

**Status:** Pending  
**Epic:** 2 - Data Management & Configuration  
**Story Number:** 2.6  
**Remplace:** Stories 2.6, 2.7, 2.8 (unifiées)

---

## Story

**As a** user en mode révision,  
**I want** to sélectionner des techniques de manière hiérarchique (positions → attaques → techniques) via une interface unifiée,  
**so that** je peux créer des entraînements ciblés en choisissant précisément les techniques à réviser.

**Note:** Cette interface est **uniquement disponible pour le mode de passage "révision"**. Le bouton d'accès sera invisible dans les autres modes de passage.

---

## Acceptance Criteria

### Visibilité et Disponibilité

1. Le bouton d'accès à l'interface de filtrage est visible uniquement lorsque le mode de passage "révision" est sélectionné
2. Le bouton est invisible/caché dans les autres modes de passage (classique, progression, aléatoire)
3. L'interface s'ouvre dans une popup (desktop) ou modal (mobile) responsive

### Interface Utilisateur

4. **Desktop (Popup):** L'interface affiche 4 colonnes, une par position (Suwariwaza, Hanmi Handachi, Tashiwaza, Armes)
5. **Mobile (Modal):** L'interface affiche une liste verticale avec sections par position (expandable/collapsible)
6. Chaque colonne/section affiche la hiérarchie complète : Position → Attaques → Techniques
7. Une barre de recherche permet de filtrer les éléments affichés en temps réel
8. Trois boutons de filtre d'affichage sont disponibles en haut à droite :
   - **Bouton 1 (P):** Afficher uniquement les positions
   - **Bouton 2 (P+A):** Afficher positions + attaques
   - **Bouton 3 (Tout):** Afficher tout (positions + attaques + techniques)
9. Les éléments sont affichés selon le mode de filtre sélectionné et le terme de recherche

### Sélection Hiérarchique

10. **Par défaut, rien n'est sélectionné** (toutes les checkboxes sont décochées)
11. **Sélection en cascade:** Sélectionner une position sélectionne automatiquement toutes ses attaques et techniques
12. **Sélection en cascade:** Sélectionner une attaque sélectionne automatiquement toutes ses techniques
13. **Désélection en cascade:** Désélectionner une position désélectionne automatiquement toutes ses attaques et techniques
14. **Désélection en cascade:** Désélectionner une attaque désélectionne automatiquement toutes ses techniques
15. Les sélections sont visuellement claires avec des checkboxes à chaque niveau

### Validation et Actions

16. **Validation:** Au moins une sélection (position, attaque ou technique) est requise pour appliquer les filtres
17. Le bouton "Appliquer" est désactivé si aucune sélection n'est faite
18. Un message d'avertissement s'affiche si aucune sélection n'est faite : "⚠️ Au moins une sélection requise"
19. Un résumé affiche le nombre de techniques sélectionnées (ex: "5 technique(s) sélectionnée(s)")
20. Des boutons "Tout sélectionner" et "Tout désélectionner" permettent de gérer rapidement toutes les sélections

### Données et Intégration

21. Les positions disponibles sont chargées selon le grade sélectionné (via GradeService.getPositionsForGrade)
22. Les attaques disponibles sont chargées selon le grade et la position (via GradeService.getAttacksForGradeAndPosition)
23. **Les techniques disponibles sont chargées selon le grade, position et attaque (via GradeService.getTechniquesForGradePositionAttack)**
24. **Seules les techniques disponibles pour le grade sélectionné sont affichées** (pas de techniques d'autres grades)
25. **Seules les attaques disponibles pour le grade sélectionné sont affichées** (pas d'attaques d'autres grades)
26. **Seules les positions disponibles pour le grade sélectionné sont affichées** (pas de positions d'autres grades)
27. Les données se mettent à jour automatiquement lorsque le grade change
28. "Randori" est exclu des positions (car c'est une annonce audio, pas une position)

### Sauvegarde et Persistance

26. La sélection est sauvegardée dans localStorage avec une clé dédiée
27. La sélection sauvegardée est chargée automatiquement lors de l'ouverture de l'interface
28. La sélection est associée au grade pour éviter les conflits entre grades différents

### Responsive Design

29. **Desktop:** Popup centrée, largeur 1000-1200px, hauteur max 80vh, 4 colonnes
30. **Tablette:** Popup adaptée, 2 colonnes (2x2) si espace insuffisant
31. **Mobile:** Modal plein écran ou presque (90vh max), liste verticale avec sections expandables
32. L'interface s'adapte automatiquement selon la taille d'écran détectée

### Accessibilité

33. Navigation au clavier fonctionnelle (Tab, Espace pour sélectionner)
34. Labels appropriés pour chaque checkbox (aria-label si nécessaire)
35. Messages d'erreur accessibles aux lecteurs d'écran
36. Contraste suffisant pour tous les éléments interactifs

---

## Tasks / Subtasks

### Phase 1: Structure du Composant

- [ ] **Task 1: Create TechniqueFilterComponent** (AC: 3, 4, 5)
  - [ ] Créer le composant `src/app/components/technique-filter/technique-filter.component.ts`
  - [ ] Créer le template `technique-filter.component.html`
  - [ ] Créer les styles `technique-filter.component.scss`
  - [ ] Définir les interfaces TypeScript (HierarchicalSelection, HierarchicalItem, DisplayMode)
  - [ ] Importer les dépendances nécessaires (GradeService, CommonModule, FormsModule)

- [ ] **Task 2: Create Models and Interfaces** (AC: 21, 22, 23)
  - [ ] Créer `src/app/models/hierarchical-selection.model.ts`
  - [ ] Définir `DisplayMode` type: 'positions' | 'positions-attacks' | 'all'
  - [ ] Définir `HierarchicalSelection` interface
  - [ ] Définir `HierarchicalItem` interface pour l'affichage

### Phase 2: Logique de Données

- [ ] **Task 3: Load Hierarchical Data** (AC: 21, 22, 23, 24, 25, 26, 27, 28)
  - [ ] Créer méthode `loadHierarchicalData(grade: string)` dans le composant
  - [ ] Utiliser GradeService.getPositionsForGrade(grade) pour obtenir **uniquement les positions du grade sélectionné**
  - [ ] Pour chaque position, utiliser getAttacksForGradeAndPosition(grade, position) pour obtenir **uniquement les attaques du grade sélectionné**
  - [ ] Pour chaque attaque, utiliser getTechniquesForGradePositionAttack(grade, position, attack) pour obtenir **uniquement les techniques du grade sélectionné**
  - [ ] Construire la structure hiérarchique complète avec uniquement les données du grade sélectionné
  - [ ] Filtrer "Randori" des positions (s'assurer qu'il n'est pas inclus)
  - [ ] Vérifier que les méthodes GradeService retournent bien uniquement les données du grade spécifié
  - [ ] Ne pas afficher de positions/attaques/techniques vides ou inexistantes pour le grade

- [ ] **Task 4: Handle Grade Changes** (AC: 27)
  - [ ] Écouter les changements de grade (via @Input ou service)
  - [ ] Recharger les données hiérarchiques lorsque le grade change avec `loadHierarchicalData(newGrade)`
  - [ ] S'assurer que seules les données du nouveau grade sont chargées
  - [ ] Réinitialiser les sélections (car les techniques peuvent être différentes entre grades)
  - [ ] Afficher un message de chargement pendant le rechargement des données

### Phase 3: Interface Utilisateur Desktop (4 Colonnes)

- [ ] **Task 5: Implement Desktop Layout (4 Columns)** (AC: 4, 29)
  - [ ] Créer structure HTML avec CSS Grid (4 colonnes égales)
  - [ ] Chaque colonne représente une position (Suwariwaza, Hanmi Handachi, Tashiwaza, Armes)
  - [ ] Style pour séparation visuelle entre colonnes (bordure droite)
  - [ ] Responsive: passer à 2 colonnes (2x2) sur tablettes (max-width: 1024px)
  - [ ] Scroll vertical indépendant par colonne si nécessaire

- [ ] **Task 6: Implement Position Column Content** (AC: 6, 15)
  - [ ] Afficher checkbox pour la position (en-tête de colonne)
  - [ ] Afficher liste des attaques de cette position
  - [ ] Afficher liste des techniques de chaque attaque (selon displayMode)
  - [ ] Indentation visuelle pour montrer la hiérarchie (attaque → techniques)
  - [ ] Style pour les checkboxes à chaque niveau

### Phase 4: Interface Utilisateur Mobile (Liste Verticale)

- [ ] **Task 7: Implement Mobile Layout (Vertical List)** (AC: 5, 31)
  - [ ] Créer structure HTML avec liste verticale
  - [ ] Sections expandables/collapsibles par position
  - [ ] Afficher attaques et techniques dans chaque section
  - [ ] Style pour mobile (plein écran ou presque)
  - [ ] Animation slide-up pour l'ouverture de la modal

### Phase 5: Barre de Recherche et Filtres d'Affichage

- [ ] **Task 8: Implement Search Bar** (AC: 7, 9)
  - [ ] Ajouter champ de recherche en haut de l'interface
  - [ ] Implémenter filtrage en temps réel (input event)
  - [ ] Filtrer positions, attaques et techniques selon le terme de recherche
  - [ ] Afficher uniquement les éléments correspondants (et leurs parents si nécessaire)
  - [ ] Style pour la barre de recherche (icône, placeholder)

- [ ] **Task 9: Implement Display Mode Buttons** (AC: 8, 9)
  - [ ] Créer 3 boutons de filtre d'affichage (P, P+A, Tout)
  - [ ] Positionner en haut à droite de l'interface
  - [ ] Implémenter logique de filtrage selon le mode sélectionné
  - [ ] Style pour boutons actifs/inactifs
  - [ ] Mode "positions": afficher uniquement les checkboxes de positions
  - [ ] Mode "positions-attacks": afficher positions + attaques (masquer techniques)
  - [ ] Mode "all": afficher tout (positions + attaques + techniques)

### Phase 6: Logique de Sélection en Cascade

- [ ] **Task 10: Implement Cascade Selection Logic** (AC: 11, 12, 13, 14)
  - [ ] Créer méthode `onPositionToggle(position: Position)`
  - [ ] Si position sélectionnée → sélectionner toutes ses attaques et techniques
  - [ ] Si position désélectionnée → désélectionner toutes ses attaques et techniques
  - [ ] Créer méthode `onAttackToggle(position: Position, attack: string)`
  - [ ] Si attaque sélectionnée → sélectionner toutes ses techniques
  - [ ] Si attaque désélectionnée → désélectionner toutes ses techniques
  - [ ] Créer méthode `onTechniqueToggle(position: Position, attack: string, technique: string)`
  - [ ] Gérer la sélection/désélection individuelle des techniques
  - [ ] Mettre à jour l'état visuel des checkboxes en temps réel

- [ ] **Task 11: Implement Selection State Management** (AC: 10, 15)
  - [ ] Créer propriétés pour stocker les sélections:
    - `selectedPositions: Set<Position>`
    - `selectedAttacks: Map<Position, Set<string>>`
    - `selectedTechniques: Map<string, Set<string>>` (clé: "Position-Attaque")
  - [ ] Initialiser toutes les sélections comme vides (par défaut)
  - [ ] Créer getters pour vérifier l'état de sélection:
    - `isPositionSelected(position: Position): boolean`
    - `isAttackSelected(position: Position, attack: string): boolean`
    - `isTechniqueSelected(position: Position, attack: string, technique: string): boolean`

### Phase 7: Validation et Actions

- [ ] **Task 12: Implement Validation** (AC: 16, 17, 18)
  - [ ] Créer getter `hasSelection: boolean` pour vérifier si au moins une sélection existe
  - [ ] Désactiver bouton "Appliquer" si `!hasSelection`
  - [ ] Afficher message d'avertissement si aucune sélection
  - [ ] Style pour message d'erreur/avertissement

- [ ] **Task 13: Implement Selection Summary** (AC: 19)
  - [ ] Créer méthode `calculateSelectedTechniquesCount(): number`
  - [ ] Calculer le nombre total de techniques sélectionnées (en tenant compte de la cascade)
  - [ ] Afficher le résumé dans le footer: "X technique(s) sélectionnée(s)"
  - [ ] Mettre à jour le résumé en temps réel lors des changements de sélection

- [ ] **Task 14: Implement Select All / Deselect All** (AC: 20)
  - [ ] Créer méthode `selectAll()`: sélectionner toutes les positions (cascade automatique)
  - [ ] Créer méthode `deselectAll()`: désélectionner tout
  - [ ] Ajouter boutons "Tout sélectionner" et "Tout désélectionner" dans le footer
  - [ ] Connecter les boutons aux méthodes

### Phase 8: Sauvegarde et Persistance

- [ ] **Task 15: Implement localStorage Persistence** (AC: 26, 27, 28)
  - [ ] Créer méthode `saveToLocalStorage(grade: string, selection: HierarchicalSelection)`
  - [ ] Utiliser clé: `technique-filter-selection-${grade}` pour associer au grade
  - [ ] Sérialiser la sélection en JSON
  - [ ] Gérer les erreurs de quota localStorage (try/catch)
  - [ ] Créer méthode `loadFromLocalStorage(grade: string): HierarchicalSelection | null`
  - [ ] Charger la sélection sauvegardée lors de l'initialisation du composant
  - [ ] Appliquer la sélection chargée aux checkboxes

### Phase 9: Intégration dans ConfigComponent

- [ ] **Task 16: Add Button in ConfigComponent** (AC: 1, 2)
  - [ ] Ajouter propriété `passageMode: string` dans ConfigComponent (si pas déjà présente)
  - [ ] Créer getter `shouldShowTechniqueFilter(): boolean` qui retourne `this.passageMode === 'revision'`
  - [ ] Ajouter bouton dans template ConfigComponent avec `*ngIf="shouldShowTechniqueFilter"`
  - [ ] Style pour le bouton (cohérent avec le reste de l'interface)

- [ ] **Task 17: Implement Popup/Modal Opening** (AC: 3, 29, 31)
  - [ ] Créer méthode `openTechniqueFilter()` dans ConfigComponent
  - [ ] Détecter si on est sur mobile ou desktop (window.innerWidth < 768)
  - [ ] Utiliser Angular CDK Overlay ou créer composant modal personnalisé
  - [ ] Configurer popup desktop: largeur 1200px, hauteur max 80vh, centré
  - [ ] Configurer modal mobile: largeur 100vw, hauteur max 90vh, slide-up
  - [ ] Passer données au composant TechniqueFilterComponent:
    - `grade: this.selectedGrade`
    - `currentSelection: this.currentTechniqueSelection` (si existe)
    - `isMobile: boolean`

- [ ] **Task 18: Handle Filter Result** (AC: 26)
  - [ ] Écouter la fermeture de la popup/modal
  - [ ] Récupérer la sélection retournée
  - [ ] Sauvegarder dans ConfigComponent
  - [ ] Sauvegarder dans localStorage via ConfigService
  - [ ] Utiliser la sélection pour la génération du passage (Story 2.9)

### Phase 10: Styles et Responsive

- [ ] **Task 19: Implement Desktop Styles** (AC: 29, 30)
  - [ ] Style pour popup desktop (backdrop semi-transparent, centré)
  - [ ] Style pour grid 4 colonnes (gap, padding, bordures)
  - [ ] Style pour checkboxes à chaque niveau (taille, espacement, indentation)
  - [ ] Style pour header (recherche + boutons filtres)
  - [ ] Style pour footer (résumé + actions)
  - [ ] Media query pour tablettes (2 colonnes au lieu de 4)

- [ ] **Task 20: Implement Mobile Styles** (AC: 31)
  - [ ] Style pour modal mobile (backdrop opaque, slide-up animation)
  - [ ] Style pour liste verticale (sections expandables)
  - [ ] Style pour checkboxes en liste verticale
  - [ ] Style responsive pour tous les éléments

### Phase 11: Accessibilité

- [ ] **Task 21: Add Accessibility Features** (AC: 33, 34, 35, 36)
  - [ ] Ajouter aria-label pour chaque checkbox
  - [ ] Ajouter aria-describedby pour les messages d'erreur
  - [ ] Assurer navigation clavier (Tab, Espace, Enter)
  - [ ] Tester avec lecteur d'écran
  - [ ] Vérifier contraste des couleurs (WCAG AA minimum)

### Phase 12: Tests

- [ ] **Task 22: Create Unit Tests**
  - [ ] Tester le chargement des données hiérarchiques
  - [ ] Tester la logique de sélection en cascade
  - [ ] Tester la validation (au moins une sélection requise)
  - [ ] Tester la sauvegarde/chargement localStorage
  - [ ] Tester le filtrage par recherche
  - [ ] Tester les modes d'affichage (P, P+A, Tout)
  - [ ] Tester la détection mobile/desktop

- [ ] **Task 23: Create Integration Tests**
  - [ ] Tester l'intégration avec ConfigComponent
  - [ ] Tester l'ouverture/fermeture de la popup/modal
  - [ ] Tester la transmission de la sélection au ConfigComponent
  - [ ] Tester la visibilité conditionnelle (mode révision uniquement)

---

## Dev Notes

### Previous Story Insights

**Source:** Story 2.2 - JSON Parsing and Data Structure
- GradeService.getPositionsForGrade(grade) retourne Position[]
- GradeService.getAttacksForGradeAndPosition(grade, position) retourne string[]
- GradeService.getTechniquesForGradePositionAttack(grade, position, attack) retourne string[]
- GradeService exclut "Randori" des positions automatiquement

**Source:** Story 2.3 - Grade Selection Interface
- Le grade sélectionné est disponible dans ConfigComponent (selectedGrade)

**Source:** Story 1.4 - Core Services Structure
- Position type est défini dans position.model.ts
- PassageFilters interface existe déjà

### Technical Context

**Source:** [architecture/components.md](../../architecture/components.md)

**Position Type:**
```typescript
type Position = 'Suwariwaza' | 'Hanmi Handachi' | 'Tashiwaza' | 'Armes';
// Note: 'Randori' est exclu car c'est une annonce audio, pas une position
```

**GradeService Methods:**
- `getPositionsForGrade(grade: string): Position[]` - Retourne **uniquement** les positions disponibles pour le grade spécifié
- `getAttacksForGradeAndPosition(grade: string, position: Position): string[]` - Retourne **uniquement** les attaques disponibles pour le grade et position spécifiés
- `getTechniquesForGradePositionAttack(grade: string, position: Position, attack: string): string[]` - Retourne **uniquement** les techniques disponibles pour le grade, position et attaque spécifiés

**Important:** Ces méthodes retournent déjà uniquement les données du grade spécifié. Il faut s'assurer de toujours passer le grade correct et de ne pas afficher de données d'autres grades.

**ConfigComponent:**
- **Location:** `src/app/pages/config/config.ts` et `config.html`
- **Dependency:** GradeService pour obtenir les données hiérarchiques
- **Passage Mode:** Vérifier si `passageMode === 'revision'` pour afficher le bouton

**UI/UX Considerations:**
- Desktop: 4 colonnes (une par position) pour vue d'ensemble optimale
- Mobile: Liste verticale avec sections expandables pour économiser l'espace
- Barre de recherche pour faciliter la navigation dans de longues listes
- 3 modes d'affichage pour réduire la complexité visuelle si nécessaire

**Default Behavior:**
- Par défaut, rien n'est sélectionné (toutes les checkboxes décochées)
- Au moins une sélection requise pour appliquer
- **Seules les données du grade sélectionné sont chargées et affichées**
- Les positions/attaques/techniques d'autres grades ne sont jamais affichées

**Validation:**
- Au moins une sélection (position, attaque ou technique) requise
- Le bouton "Appliquer" est désactivé si aucune sélection

**Sauvegarde:**
- Clé localStorage: `technique-filter-selection-${grade}`
- Associer la sélection au grade pour éviter les conflits

### Implementation Details

**Component Structure:**
```typescript
@Component({
  selector: 'app-technique-filter',
  templateUrl: './technique-filter.component.html',
  styleUrls: ['./technique-filter.component.scss'],
  standalone: true,
  imports: [CommonModule, FormsModule]
})
export class TechniqueFilterComponent {
  @Input() grade: string = '';
  @Input() currentSelection: HierarchicalSelection | null = null;
  @Input() isMobile: boolean = false;
  
  @Output() selectionApplied = new EventEmitter<HierarchicalSelection>();
  @Output() cancelled = new EventEmitter<void>();
  
  displayMode: DisplayMode = 'all';
  searchTerm: string = '';
  
  positions: Position[] = ['Suwariwaza', 'Hanmi Handachi', 'Tashiwaza', 'Armes'];
  hierarchicalData: Map<Position, HierarchicalPositionData> = new Map();
  
  selectedPositions: Set<Position> = new Set();
  selectedAttacks: Map<Position, Set<string>> = new Map();
  selectedTechniques: Map<string, Set<string>> = new Map();
  
  constructor(private gradeService: GradeService) {}
  
  ngOnInit(): void {
    // Charger uniquement les données du grade sélectionné
    this.loadHierarchicalData(this.grade);
    if (this.currentSelection) {
      // Vérifier que la sélection chargée correspond au grade actuel
      if (this.currentSelection.grade === this.grade) {
        this.applySelection(this.currentSelection);
      } else {
        // Si le grade a changé, réinitialiser la sélection
        this.deselectAll();
      }
    } else {
      this.loadFromLocalStorage(this.grade);
    }
  }
  
  loadHierarchicalData(grade: string): void {
    // S'assurer de charger uniquement les données du grade spécifié
    this.positions = this.gradeService.getPositionsForGrade(grade);
    
    // Construire la structure hiérarchique avec uniquement les données du grade
    this.hierarchicalData.clear();
    this.positions.forEach(position => {
      const attacks = this.gradeService.getAttacksForGradeAndPosition(grade, position);
      const positionData: HierarchicalPositionData = {
        position,
        attacks: new Map()
      };
      
      attacks.forEach(attack => {
        const techniques = this.gradeService.getTechniquesForGradePositionAttack(grade, position, attack);
        positionData.attacks.set(attack, techniques);
      });
      
      this.hierarchicalData.set(position, positionData);
    });
  }
  
  // ... méthodes d'implémentation
}
```

**Template Structure (Desktop - 4 Colonnes):**
```html
<div class="technique-filter-container" [class.mobile]="isMobile">
  <!-- Header -->
  <div class="filter-header">
    <input 
      type="text" 
      class="search-input"
      placeholder="Rechercher..."
      [(ngModel)]="searchTerm"
      (input)="onSearchChange($event)">
    
    <div class="display-mode-buttons">
      <button 
        *ngFor="let mode of displayModes"
        [class.active]="displayMode === mode.id"
        (click)="onDisplayModeChange(mode.id)">
        {{ mode.label }}
      </button>
    </div>
  </div>
  
  <!-- 4 Colonnes Desktop -->
  <div class="positions-grid" *ngIf="!isMobile">
    <div 
      *ngFor="let position of positions" 
      class="position-column">
      <div class="position-header">
        <label class="position-checkbox">
          <input 
            type="checkbox"
            [checked]="isPositionSelected(position)"
            (change)="onPositionToggle(position)">
          <span>{{ position }}</span>
        </label>
      </div>
      
      <div class="attacks-list">
        <div 
          *ngFor="let attack of getAttacksForPosition(position)"
          class="attack-item">
          <label class="attack-checkbox">
            <input 
              type="checkbox"
              [checked]="isAttackSelected(position, attack)"
              (change)="onAttackToggle(position, attack)">
            <span>{{ attack }}</span>
          </label>
          
          <div 
            *ngIf="displayMode === 'all'"
            class="techniques-list">
            <label 
              *ngFor="let technique of getTechniquesForPositionAttack(position, attack)"
              class="technique-checkbox">
              <input 
                type="checkbox"
                [checked]="isTechniqueSelected(position, attack, technique)"
                (change)="onTechniqueToggle(position, attack, technique)">
              <span>{{ technique }}</span>
            </label>
          </div>
        </div>
      </div>
    </div>
  </div>
  
  <!-- Liste Verticale Mobile -->
  <div class="positions-list" *ngIf="isMobile">
    <!-- Structure similaire mais en liste verticale -->
  </div>
  
  <!-- Footer -->
  <div class="filter-footer">
    <div class="selection-summary">
      {{ selectedTechniquesCount }} technique(s) sélectionnée(s)
      <span *ngIf="!hasSelection" class="error-message">
        ⚠️ Au moins une sélection requise
      </span>
    </div>
    
    <div class="action-buttons">
      <button (click)="selectAll()">Tout sélectionner</button>
      <button (click)="deselectAll()">Tout désélectionner</button>
    </div>
    
    <div class="dialog-actions">
      <button (click)="cancel()">Annuler</button>
      <button 
        [disabled]="!hasSelection"
        (click)="apply()">
        Appliquer
      </button>
    </div>
  </div>
</div>
```

**Styling:**
- Utiliser les variables CSS du thème
- Grid 4 colonnes pour desktop (responsive 2 colonnes sur tablettes)
- Liste verticale pour mobile
- Indentation visuelle pour la hiérarchie
- Style pour checkboxes à chaque niveau
- Messages d'erreur avec style distinct

---

## Dependencies

- ✅ Story 2.2 complétée (getPositionsForGrade, getAttacksForGradeAndPosition, getTechniquesForGradePositionAttack)
- ✅ Story 2.3 complétée (grade sélectionné disponible)
- ✅ Position type défini (Story 1.4)
- ✅ PassageFilters interface existe (Story 1.4)
- ⏳ Story 2.9 (Configuration Page Complete Integration) - Utilisera la sélection pour générer le passage

---

## Testing Checklist

- [ ] Test: Bouton visible uniquement en mode révision
- [ ] Test: Bouton invisible dans les autres modes
- [ ] Test: Popup s'ouvre sur desktop (4 colonnes)
- [ ] Test: Modal s'ouvre sur mobile (liste verticale)
- [ ] Test: 4 colonnes affichées correctement (Suwariwaza, Hanmi Handachi, Tashiwaza, Armes)
- [ ] Test: Positions chargées selon le grade (uniquement celles du grade sélectionné)
- [ ] Test: Attaques chargées selon position et grade (uniquement celles du grade sélectionné)
- [ ] Test: Techniques chargées selon position, attaque et grade (uniquement celles du grade sélectionné)
- [ ] Test: Aucune technique d'un autre grade n'est affichée
- [ ] Test: Aucune attaque d'un autre grade n'est affichée
- [ ] Test: Aucune position d'un autre grade n'est affichée
- [ ] Test: Changement de grade recharge uniquement les données du nouveau grade
- [ ] Test: "Randori" n'apparaît pas dans les positions
- [ ] Test: Par défaut, rien n'est sélectionné
- [ ] Test: Sélection position → sélectionne toutes ses attaques et techniques
- [ ] Test: Sélection attaque → sélectionne toutes ses techniques
- [ ] Test: Désélection position → désélectionne toutes ses attaques et techniques
- [ ] Test: Désélection attaque → désélectionne toutes ses techniques
- [ ] Test: Barre de recherche filtre correctement
- [ ] Test: Mode "P" affiche uniquement positions
- [ ] Test: Mode "P+A" affiche positions + attaques
- [ ] Test: Mode "Tout" affiche positions + attaques + techniques
- [ ] Test: Validation (au moins une sélection requise)
- [ ] Test: Bouton "Appliquer" désactivé si aucune sélection
- [ ] Test: Résumé affiche le bon nombre de techniques
- [ ] Test: "Tout sélectionner" fonctionne
- [ ] Test: "Tout désélectionner" fonctionne
- [ ] Test: Sauvegarde localStorage fonctionne
- [ ] Test: Chargement localStorage fonctionne
- [ ] Test: Sélection associée au grade (pas de conflit)
- [ ] Test: Responsive desktop → tablette (4 → 2 colonnes)
- [ ] Test: Responsive tablette → mobile (popup → modal)
- [ ] Test: Accessibilité (navigation clavier, labels)
- [ ] Test: Intégration avec ConfigComponent
- [ ] Test: Transmission de la sélection au ConfigComponent

---

## Definition of Done

- ✅ Tous les Acceptance Criteria sont remplis
- ✅ Code compile sans erreurs
- ✅ Tests unitaires passent (couverture minimale 70%)
- ✅ Tests d'intégration passent
- ✅ Intégration GradeService fonctionne
- ✅ "Randori" est exclu de la liste
- ✅ Sélection en cascade fonctionne correctement
- ✅ Validation fonctionne (au moins une sélection requise)
- ✅ Sauvegarde/chargement localStorage fonctionne
- ✅ Interface responsive (desktop 4 colonnes, mobile liste verticale)
- ✅ Accessibilité de base respectée (WCAG AA)
- ✅ Code review effectué
- ✅ Documentation du code (JSDoc) ajoutée
- ✅ Intégration avec ConfigComponent validée
- ✅ Visibilité conditionnelle (mode révision uniquement) validée

---

## Notes de Migration

Cette story remplace les stories 2.6, 2.7 et 2.8. Les fonctionnalités suivantes sont **unifiées** dans cette nouvelle interface :

- **Story 2.6 (Position Filtering):** Intégrée dans l'interface hiérarchique
- **Story 2.7 (Attack and Technique Filtering):** Intégrée dans l'interface hiérarchique
- **Story 2.8 (Weapons and Randori):** La partie Randori reste dans Story 2.8 (annonce audio finale), mais les filtres de techniques sont ici

**Action requise:** Marquer les stories 2.6, 2.7 comme "Replaced by 2.6 (unified)" dans le workflow state.
